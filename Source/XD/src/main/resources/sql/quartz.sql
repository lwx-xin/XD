#
# Quartz seems to work best with the driver mm.mysql-2.0.7-bin.jar
#
# PLEASE consider using mysql with innodb tables to avoid locking issues
#
# In your Quartz properties file, you'll need to set
# org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate
#

DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;
DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;
DROP TABLE IF EXISTS QRTZ_LOCKS;
DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;
DROP TABLE IF EXISTS QRTZ_CALENDARS;


CREATE TABLE QRTZ_JOB_DETAILS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    JOB_NAME  VARCHAR(200) NOT NULL COMMENT '集群中job的名字',
    JOB_GROUP VARCHAR(200) NOT NULL COMMENT '集群中job的所属组的名字',
    DESCRIPTION VARCHAR(250) NULL COMMENT '详细描述信息',
    JOB_CLASS_NAME   VARCHAR(250) NOT NULL COMMENT '集群中个notejob实现类的全限定名,quartz就是根据这个路径到classpath找到该job类',
    IS_DURABLE VARCHAR(1) NOT NULL COMMENT '是否持久化,把该属性设置为1，quartz会把job持久化到数据库中',
    IS_NONCONCURRENT VARCHAR(1) NOT NULL COMMENT '是否并发执行',
    IS_UPDATE_DATA VARCHAR(1) NOT NULL COMMENT '是否更新数据',
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL COMMENT '是否接受恢复执行，默认为false，设置了RequestsRecovery为true，则该job会被重新执行',
    JOB_DATA BLOB NULL COMMENT '一个blob字段，存放持久化job对象',
    PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
) COMMENT = '存储每一个已配置的Job的详细信息';

CREATE TABLE QRTZ_TRIGGERS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT '触发器的名字',
    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT '触发器所属组的名字',
    JOB_NAME  VARCHAR(200) NOT NULL COMMENT 'qrtz_job_details表job_name的外键',
    JOB_GROUP VARCHAR(200) NOT NULL COMMENT 'qrtz_job_details表job_group的外键',
    DESCRIPTION VARCHAR(250) NULL NULL COMMENT '详细描述信息',
    NEXT_FIRE_TIME BIGINT(13) NULL COMMENT '下一次触发时间，默认为-1，意味不会自动触发',
    PREV_FIRE_TIME BIGINT(13) NULL COMMENT '上一次触发时间（毫秒）',
    PRIORITY INTEGER NULL COMMENT '优先级',
    TRIGGER_STATE VARCHAR(16) NOT NULL COMMENT '当前触发器状态，设置为ACQUIRED,如果设置为WAITING,则job不会触发 （ WAITING:等待 PAUSED:暂停ACQUIRED:正常执行 BLOCKED：阻塞 ERROR：错误）',
    TRIGGER_TYPE VARCHAR(8) NOT NULL COMMENT '触发器的类型，使用cron表达式',
    START_TIME BIGINT(13) NOT NULL COMMENT '开始时间',
    END_TIME BIGINT(13) NULL COMMENT '结束时间',
    CALENDAR_NAME VARCHAR(200) NULL COMMENT '日程表名称，表qrtz_calendars的calendar_name字段外键',
    MISFIRE_INSTR SMALLINT(2) NULL COMMENT '措施或者是补偿执行的策略',
    JOB_DATA BLOB NULL COMMENT '一个blob字段，存放持久化job对象',
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
        REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP)
) COMMENT = '存储已配置的触发器的基本信息';

CREATE TABLE QRTZ_SIMPLE_TRIGGERS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_ name的外键',
    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_group的外键',
    REPEAT_COUNT BIGINT(7) NOT NULL COMMENT '重复的次数统计',
    REPEAT_INTERVAL BIGINT(12) NOT NULL COMMENT '重复的间隔时间',
    TIMES_TRIGGERED BIGINT(10) NOT NULL COMMENT '已经触发的次数',
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) COMMENT = '存储简单的 Trigger，包括重复次数，间隔，以及已触的次数';

CREATE TABLE QRTZ_CRON_TRIGGERS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_name的外键',
    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_group的外键',
    CRON_EXPRESSION VARCHAR(200) NOT NULL COMMENT 'cron表达式',
    TIME_ZONE_ID VARCHAR(80) COMMENT '时区',
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) COMMENT = '存储Cron Trigger，包括Cron表达式和时区信息。';

CREATE TABLE QRTZ_SIMPROP_TRIGGERS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_ name的外键',
    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_group的外键',
    STR_PROP_1 VARCHAR(512) NULL COMMENT 'String类型的trigger的第一个参数',
    STR_PROP_2 VARCHAR(512) NULL COMMENT 'String类型的trigger的第二个参数',
    STR_PROP_3 VARCHAR(512) NULL COMMENT 'String类型的trigger的第三个参数',
    INT_PROP_1 INT NULL COMMENT 'int类型的trigger的第一个参数',
    INT_PROP_2 INT NULL COMMENT 'int类型的trigger的第二个参数',
    LONG_PROP_1 BIGINT NULL COMMENT 'long类型的trigger的第一个参数',
    LONG_PROP_2 BIGINT NULL COMMENT 'long类型的trigger的第二个参数',
    DEC_PROP_1 NUMERIC(13,4) NULL COMMENT 'decimal类型的trigger的第一个参数',
    DEC_PROP_2 NUMERIC(13,4) NULL COMMENT 'decimal类型的trigger的第二个参数',
    BOOL_PROP_1 VARCHAR(1) NULL COMMENT 'Boolean类型的trigger的第一个参数',
    BOOL_PROP_2 VARCHAR(1) NULL COMMENT 'Boolean类型的trigger的第二个参数',
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) COMMENT '存储CalendarIntervalTrigger和DailyTimeIntervalTrigger';

CREATE TABLE QRTZ_BLOB_TRIGGERS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_name的外键',
    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_group的外键',
    BLOB_DATA BLOB NULL COMMENT '一个blob字段，存放持久化Trigger对象',
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) COMMENT = 'Trigger作为Blob类型存储（用于Quartz用户用JDBC创建他们自己定制的Trigger类型，JobStore 并不知道如何存储实例的时候）';

CREATE TABLE QRTZ_CALENDARS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    CALENDAR_NAME  VARCHAR(200) NOT NULL COMMENT '日历名称',
    CALENDAR BLOB NOT NULL COMMENT '一个blob字段，存放持久化calendar对象',
    PRIMARY KEY (SCHED_NAME,CALENDAR_NAME)
) COMMENT = '以Blob类型存储Quartz的Calendar日历信息， quartz可配置一个日历来指定一个时间范围';

CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    TRIGGER_GROUP  VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_group的外键',
    PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP)
) COMMENT = '存储已暂停的Trigger组的信息';

CREATE TABLE QRTZ_FIRED_TRIGGERS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    ENTRY_ID VARCHAR(95) NOT NULL COMMENT '调度器实例id',
    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_name的外键',
    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'qrtz_triggers表trigger_group的外键',
    INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT '调度器实例名',
    FIRED_TIME BIGINT(13) NOT NULL COMMENT '触发的时间',
    SCHED_TIME BIGINT(13) NOT NULL COMMENT '定时器制定的时间',
    PRIORITY INTEGER NOT NULL COMMENT '优先级',
    STATE VARCHAR(16) NOT NULL COMMENT '状态',
    JOB_NAME VARCHAR(200) NULL COMMENT '集群中job的名字',
    JOB_GROUP VARCHAR(200) NULL COMMENT '集群中job的所属组的名字',
    IS_NONCONCURRENT VARCHAR(1) NULL COMMENT '是否并发',
    REQUESTS_RECOVERY VARCHAR(1) NULL COMMENT '是否接受恢复执行，默认为false，设置了RequestsRecovery为true，则会被重新执行',
    PRIMARY KEY (SCHED_NAME,ENTRY_ID)
) COMMENT = '存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息';

CREATE TABLE QRTZ_SCHEDULER_STATE
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT '之前配置文件中org.quartz.scheduler.instanceId配置的名字，就会写入该字段',
    LAST_CHECKIN_TIME BIGINT(13) NOT NULL COMMENT '上次检查时间',
    CHECKIN_INTERVAL BIGINT(13) NOT NULL COMMENT '检查间隔时间',
    PRIMARY KEY (SCHED_NAME,INSTANCE_NAME)
) COMMENT = '存储集群中note实例信息，quartz会定时读取该表的信息判断集群中每个实例的当前状态';

CREATE TABLE QRTZ_LOCKS
(
    SCHED_NAME VARCHAR(120) NOT NULL COMMENT '调度名称',
    LOCK_NAME  VARCHAR(40) NOT NULL COMMENT '悲观锁名称',
    PRIMARY KEY (SCHED_NAME,LOCK_NAME)
) COMMENT = '存储程序的非观锁的信息(假如使用了悲观锁)';

commit;
